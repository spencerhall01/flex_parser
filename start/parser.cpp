/*********************************************************************
 Name: John Spencer Hall
 NetID: jsh278
 Course: CSE 4714
 Assignment: Part 2 - Recursive Descent Parser for TIPS Language
 Programming Environment: C++ and Flex
 Purpose of File: Grammer rules for parsing TIPS language.
*********************************************************************/
#ifdef _MSC_VER
#define _CRT_SECURE_NO_WARNINGS
#endif

#include <stdlib.h>
#include <iostream>
#include "lexer.h"
#include "parser.h"
 
using namespace std;

int  nextToken = 0;           // hold nextToken returned by lex
bool printParse = false;      // shall we print the parse tree?

// Which tree level are we currently in?
static int level = 0;

// Symbol table (list of variables declared in the program) 
symbolTableT symbolTable;

//*****************************************************************************
// Indent to reveal tree structure
string psp(void) { // Stands for p-space, but I want the name short
  string str("");
  for(int i = 0; i < level; i++)
    str += "|  ";
  return str;
}
//*****************************************************************************
// Get the next lexeme (word in sentence)
int lex() 
{
  nextToken = yylex();
  return nextToken;
}
//*****************************************************************************
// Report what we found
void output(string what) {
  cout << psp() << "found |" << yytext << "| " << what << endl;
}
//*****************************************************************************
// Forward declarations of FIRST_OF functions.  These check whether the current 
// token is in the FIRST set of a production rule.
bool first_of_program(void);
bool first_of_block(void);
bool first_of_statement(void);
bool first_of_assignment(void);
bool first_of_compound_stmt(void);
bool first_of_if(void);
bool first_of_while(void);
bool first_of_read(void);
bool first_of_write(void);
bool first_of_expression(void);
bool first_of_simple_expr(void);
bool first_of_term(void);
bool first_of_factor(void);
//*****************************************************************************
// Parses strings in the language generated by the rule:
// <program> â†’ TOK_PROGRAM TOK_IDENT TOK_SEMICOLON <block>
ProgramNode* program() 
{
    // Expect keyword 'PROGRAM'
	if (!first_of_program()) {
        throw "3: 'PROGRAM' expected";
	} else {
		if(printParse) output("PROGRAM");
		lex();
	}
	
	// Print entry
	if (printParse)
		cout << psp() << "enter <program>" << endl;
	ProgramNode* newProgramNode = new ProgramNode(level);
    ++level;
	
    // Expect an identifier
    if (nextToken == TOK_IDENT) {
        if(printParse) output("IDENTIFIER");
		lex();
    } else {
        throw "2: identifier expected";
    }
	
    // Expect a semicolon ';'
    if (nextToken == TOK_SEMICOLON) {
        if(printParse) output("SEMICOLON");
		lex();
    } else {
        throw "14: ';' expected";
    }
	
    // Parse <block>
    newProgramNode->_block = block();
	
	// Print exit
    --level;
	if(printParse)
		cout << psp() << "exit <program>" << endl;
	return newProgramNode;
}

bool first_of_program() {
    return nextToken == TOK_PROGRAM;
}

/*********
 * BLOCK *
 *********/

BlockNode* block()
{
    // Expect keyword 'VAR' or 'BEGIN'
	if (!first_of_block()) {
        throw "18: error in declaration part OR 17: 'BEGIN' expected";
	} else {
		if(printParse) output("BLOCK");
	}
	
	// Print entry
	if(printParse)
		cout << psp() << "enter <block>" << endl;
	BlockNode* newBlockNode = new BlockNode(level);
    ++level;
	
	// Temporarily store symbol names and types for printing
	string idName;
	string idType;

    // Check for optional variable declarations
    if (nextToken == TOK_VAR) {
		lex();

        // Parse the first variable declaration
        if (nextToken == TOK_IDENT) {
			// Check if symbol is in symbol table
			if (symbolTable.count(yytext) == 0) {
				symbolTable.insert({yytext,0.0});
			} else {
				throw "101: identifier declared twice";
			}
			idName = yytext; // Store the symbol to print later
            if(printParse) output("IDENTIFIER");
			lex();

            // Expect a colon ':'
            if (nextToken == TOK_COLON) {
                if(printParse) output("COLON");
				lex();
                
                // Expect keyword 'INTEGER' or 'REAL'
                if (nextToken == TOK_INTEGER || nextToken == TOK_REAL) {
					idType = yytext; // Store the type to print later
                    if(printParse) output("TYPE");
					lex();

                    // Expect a semicolon ';'
                    if (nextToken == TOK_SEMICOLON) {
                        if(printParse) output("SEMICOLON");
						lex();
						
						// Print the symbol and its type
						if(printParse)
							cout << psp() << "-- idName: |" << idName << "| idType: |" << idType << "| --\n";
						
                    } else {
                        throw "14: ';' expected";
                    }
                } else {
                    throw "10: error in type" ;
                }
            } else {
                throw "5: ':' expected";
            }
        } else {
            throw "2: identifier expected";
        }

        // Parse any additional variable declarations
        while (nextToken == TOK_IDENT) {
			if (symbolTable.count(yytext) == 0) {
				symbolTable.insert({yytext,0.0});
			} else {
				idName = yytext; // Store the symbol to print later
				if(printParse) output("IDENTIFIER");
				lex();
				
				// Expect a colon ':'
				if (nextToken == TOK_COLON) {
					if(printParse) output("COLON");
					lex();
					
					// Expect keyword 'INTEGER' or 'REAL'
					if (nextToken == TOK_INTEGER || nextToken == TOK_REAL) {
						idType = yytext; // Store the type to print later
						if(printParse) output("TYPE");
						lex();
						
						// Expect a semicolon ';'
						if (nextToken == TOK_SEMICOLON) {
							if(printParse) output("SEMICOLON");
							
							// Print the symbol and its type
							if(printParse)
								cout << psp() << "-- idName: |" << idName << "| idType: |" << idType << "| --\n";
						}
					}
				}
				throw "101: identifier declared twice";
			}
			idName = yytext; // Store the symbol to print later
            if(printParse) output("IDENTIFIER");
			lex();

            // Expect a colon ':'
            if (nextToken == TOK_COLON) {
                if(printParse) output("COLON");
				lex();
                
                // Expect keyword 'INTEGER' or 'REAL'
                if (nextToken == TOK_INTEGER || nextToken == TOK_REAL) {
                    idType = yytext; // Store the type to print later
					if(printParse) output("TYPE");
					lex();

                    // Expect a semicolon ';'
                    if (nextToken == TOK_SEMICOLON) {
                        if(printParse) output("SEMICOLON");
						lex();
						
						// Print the symbol and its type
						if(printParse)
							cout << psp() << "-- idName: |" << idName << "| idType: |" << idType << "| --\n";
						
                    } else {
                        throw "14: ';' expected";
                    }
                } else {
                    throw "10: error in type" ;
                }
            } else {
                throw "5: ':' expected";
            }
        }
    }

    // Parse <compound>
    newBlockNode->_compoundStmt = compound_stmt();
	
	// Print exit
    --level;
	if(printParse)
		cout << psp() << "exit <block>" << endl;
	return newBlockNode;
}

bool first_of_block(void) {
    return nextToken == TOK_VAR || nextToken == TOK_BEGIN;
}

/*************
 * STATEMENT *
 *************/
 
StmtNode* statement() {
    if (!first_of_statement()) {
        throw "900: illegal type of statement";
    } else {
		if(printParse) output("STATEMENT");
	}
	
	StmtNode* newStmtNode = nullptr;
	
    // Check which type of statement to parse based on the current token
    switch (nextToken) {
        case TOK_IDENT:
            // Parse assignment statement
            newStmtNode = assignment();
            break;
        case TOK_BEGIN:
            // Parse compound statement
            newStmtNode = compound_stmt();
            break;
        case TOK_IF:
            // Parse if statement
            newStmtNode = if_stmt();
            break;
        case TOK_WHILE:
            // Parse while statement
            newStmtNode = while_stmt();
            break;
        case TOK_READ:
            // Parse read statement
            newStmtNode = read_stmt();
            break;
        case TOK_WRITE:
            // Parse write statement
            newStmtNode = write_stmt();
            break;
        default:
            throw "900: illegal type of statement";
    }
	
	return newStmtNode;
}

bool first_of_statement(void) {
    return (nextToken == TOK_IDENT || nextToken == TOK_BEGIN || 
            nextToken == TOK_IF || nextToken == TOK_WHILE || 
            nextToken == TOK_READ || nextToken == TOK_WRITE);
}

/**************
 * ASSIGNMENT *
 **************/
 
AssignNode* assignment() {
    if (!first_of_assignment()) {
        throw "900: illegal type of statement";
    }
	
	if(printParse)
		cout << psp() << "enter <assignment>" << endl;
	AssignNode* newAssignNode = new AssignNode(level);
	++level;

    // Expect an identifier (variable)
    if (nextToken == TOK_IDENT) {
        if (symbolTable.count(yytext) == 0) {
			throw "104: identifier not declared";
		} else {
			if(printParse) {
				output("IDENTIFIER");
				cout << psp() << yytext << "\n";
			}
			newAssignNode->_id = new string(yytext);
			lex();
		}
		
	}

    // Expect ':=' (assignment operator)
    if (nextToken == TOK_ASSIGN) {
        if(printParse) output("ASSIGN");
		lex();
    } else {
        throw "51: ':=' expected";
    }

    // Parse the expression on the right-hand side of the assignment
    newAssignNode->_expr = expression();

    --level;
	if(printParse)
		cout << psp() << "exit <assignment>" << endl;
	return newAssignNode;
}

bool first_of_assignment(void) {
    return nextToken == TOK_IDENT;
}

/**********************
 * COMPOUND STATEMENT *
 **********************/

CompoundNode* compound_stmt() {
	if (!first_of_compound_stmt()) {
        throw "17: 'BEGIN' expected";
    }
	
	if(printParse) {
		output("BEGIN");
		cout << psp() << "enter <compound_stmt>" << endl;
	}
	CompoundNode* newCompoundNode = new CompoundNode(level);
    ++level;

    // Expect 'BEGIN'
    if (nextToken == TOK_BEGIN) {
		lex();
    } else {
        throw "17: 'BEGIN' expected";
    }
	
	// Parse statement
    newCompoundNode->_stmts.push_back(statement());

    // Parse optional additonal statements
    while (nextToken == TOK_SEMICOLON) {
        if(printParse) output("SEMICOLON");
		lex();
		newCompoundNode->_stmts.push_back(statement());
    }

    --level;
	// Expect 'END'
    if (nextToken == TOK_END) {
        if(printParse) output("END");
		lex();
    } else {
        throw "13: 'END' expected";
    }
	if(printParse)
		cout << psp() << "exit <compound_stmt>" << endl;
	return newCompoundNode;
}

bool first_of_compound_stmt() {
    return TOK_BEGIN;
}

/****************
 * IF STATEMENT *
 ****************/

IfNode* if_stmt() {
	if (!first_of_if()) {
        throw "900: illegal type of statement";
    }
	
	if(printParse)
		cout << psp() << "enter <if>" << endl;
    IfNode* newIfNode = new IfNode(level);
	++level;

    // Expect 'IF'
    if (nextToken == TOK_IF) {
		lex();
    } else {
        throw "900: illegal type of statement";
    }
	
	// Parse expression
    newIfNode->_expr = expression();

    // Expect 'THEN'
    if (nextToken == TOK_THEN) {
        if(printParse) output("THEN");
		lex();
    } else {
        throw "52: 'THEN' expected";
    }
	
	// Parse statment
    newIfNode->_thenStmt = statement();
	
	// Optional 'ELSE'
    if (nextToken == TOK_ELSE) {
		--level;
        if(printParse) {
			output("ELSE");
			cout << psp() << "enter <else>" << endl;
		}
		++level;
		lex();
		newIfNode->_elseStmt = statement();
    }

    --level;
	if(printParse)
		cout << psp() << "exit <if>" << endl;
	return newIfNode;
}

bool first_of_if(void) {
    return TOK_IF;
}

/*******************
 * WHILE STATEMENT *
 *******************/

WhileNode* while_stmt() {
	if (!first_of_while()) {
        throw "900: illegal type of statement";
	}
	
	if(printParse)
		cout << psp() << "enter <while>" << endl;
    WhileNode* newWhileNode = new WhileNode(level);
	++level;

    // Expect 'WHILE'
    if (nextToken == TOK_WHILE) {
		lex();
    } else {
        throw "900: illegal type of statement";
    }
	
	// Parse expression
    newWhileNode->_expr = expression();
	
	// Parse statment
    newWhileNode->_stmt = statement();

    --level;
	if(printParse)
		cout << psp() << "exit <while>" << endl;
	return newWhileNode;
}

bool first_of_while(void) {
    return TOK_WHILE;
}

/******************
 * READ STATEMENT *
 ******************/

ReadNode* read_stmt() {
	if (!first_of_read()) {
        throw "900: illegal type of statement";
    }
	
	if(printParse)
		cout << psp() << "enter <read>" << endl;
    ReadNode* newReadNode = new ReadNode(level);
	++level;

    // Expect 'READ'
    if (nextToken == TOK_READ) {
		lex();
    } else {
        throw "900: illegal type of statement";
    }
	
	// Expect '('
    if (nextToken == TOK_OPENPAREN) {
		if(printParse) output("OPENPAREN");
		lex();
	} else {
		throw "9: '(' expected";
	}
	
	// Expect identifier
    if (nextToken == TOK_IDENT) {
		if (symbolTable.count(yytext) == 0) {
			throw "104: identifier not declared";
		} else {
			if(printParse) {
				output("IDENTIFIER");
				cout << psp() << yytext << "\n";
			}
			newReadNode->_id = new string(yytext);
			lex();
		}
	} else {
		throw "2: identifier expected";
	}
	
	// Expect ')'
    if (nextToken == TOK_CLOSEPAREN) {
		if(printParse) output("CLOSEPAREN");
		lex();
	} else {
		throw "4: ')' expected";
	}

    --level;
	if(printParse)
		cout << psp() << "exit <read>" << endl;
	return newReadNode;
}

bool first_of_read(void) {
    return TOK_READ;
}

/*******************
 * WRITE STATEMENT *
 *******************/

WriteNode* write_stmt() {
	if (!first_of_write()) {
        throw "900: illegal type of statement";
    }
	
	if(printParse)
		cout << psp() << "enter <write>" << endl;
    WriteNode* newWriteNode = new WriteNode(level);
	++level;

    // Expect 'WRITE'
    if (nextToken == TOK_WRITE) {
		lex();
    } else {
        throw "900: illegal type of statement";
    }
	
	// Expect '('
    if (nextToken == TOK_OPENPAREN) {
		if(printParse) output("OPENPAREN");
		lex();
	} else {
		throw "9: '(' expected";
	}
	
	// Expect identifier or string literal
    if (nextToken == TOK_IDENT || nextToken == TOK_STRINGLIT) {
		if (nextToken == TOK_IDENT) {
			if (symbolTable.count(yytext) == 0) {
				throw "104: identifier not declared";
			} else {
				if(printParse) {
					output("WRITE");
					cout << psp() << yytext << "\n";
				}
				newWriteNode->_id = new string(yytext);
				lex();
			}
		} else {
			if(printParse) {
				output("WRITE");
				cout << psp() << yytext << "\n";
			}
			newWriteNode->_string = new string(yytext);
			lex();
		}
	} else {
		throw "134: illegal type of operand(s)";
	}
	
	// Expect ')'
    if (nextToken == TOK_CLOSEPAREN) {
		if(printParse) output("CLOSEPAREN");
		lex();
	} else {
		throw "4: ')' expected";
	}

    --level;
	if(printParse)
		cout << psp() << "exit <write>" << endl;
	return newWriteNode;
}

bool first_of_write(void) {
    return TOK_WRITE;
}

/**************
 * EXPRESSION *
 **************/

ExprNode* expression() {
	if (!first_of_expression()) {
        throw "144: illegal type of expression";
    } else {
		if(printParse) output ("EXPRESSION");
	}
	
	if(printParse)
		cout << psp() << "enter <expression>" << endl;
    ExprNode* newExprNode = new ExprNode(level);
	++level;
	
	// Parse simple expression
	newExprNode->_firstSimpExpr = simple_expr();
	
    // Optional operators
    if (nextToken == TOK_EQUALTO || nextToken == TOK_LESSTHAN || nextToken == TOK_GREATERTHAN || nextToken == TOK_NOTEQUALTO) {
        if(printParse) {
			if (nextToken == TOK_EQUALTO) {
				output("EQUALTO");
				cout << psp() << yytext << "\n";
			} else if (nextToken == TOK_LESSTHAN) {
				output("LESSTHAN");
				cout << psp() << yytext << "\n";
			} else if (nextToken == TOK_GREATERTHAN) {
				output("GREATERTHAN");
				cout << psp() << yytext << "\n";
			} else {
				output("NOTEQUALTO");
				cout << psp() << yytext << "\n";
			}
		}
		newExprNode->_compareOp = nextToken;
		lex();
		newExprNode->_secondSimpExpr = simple_expr();
    }
	
    --level;
	if(printParse)
		cout << psp() << "exit <expression>" << endl;
	return newExprNode;
}

bool first_of_expression(void) {
	return (nextToken == TOK_INTLIT || nextToken == TOK_FLOATLIT || 
            nextToken == TOK_IDENT || nextToken == TOK_OPENPAREN || 
            nextToken == TOK_NOT || nextToken == TOK_MINUS);
}

/*********************
 * SIMPLE EXPRESSION *
 *********************/

SimpExprNode* simple_expr() {
	if (!first_of_simple_expr()) {
        throw "901: illegal type of simple expression";
    } else {
		if(printParse) output("SIMPLE_EXP");
	}
	
	if(printParse)
		cout << psp() << "enter <simple_exp>" << endl;
    SimpExprNode* newSimpExprNode = new SimpExprNode(level);
	++level;
	
	// Parse term
	newSimpExprNode->_firstTerm = term();
	
    // Optional operators
    while (nextToken == TOK_PLUS || nextToken == TOK_MINUS || nextToken == TOK_OR) {
        if(printParse) {
			if (nextToken == TOK_PLUS) {
				output("PLUS");
				cout << psp() << yytext << "\n";
			} else if (nextToken == TOK_MINUS) {
				output("MINUS");
				cout << psp() << yytext << "\n";
			} else {
				output("OR");
				cout << psp() << yytext << "\n";
			}
		}
		newSimpExprNode->_termOps.push_back(nextToken);
		lex();
		newSimpExprNode->_restTerms.push_back(term());
    }
	
    --level;
	if(printParse)
		cout << psp() << "exit <simple_exp>" << endl;
	return newSimpExprNode;
}

bool first_of_simple_expr(void) {
	return (nextToken == TOK_INTLIT || nextToken == TOK_FLOATLIT || 
            nextToken == TOK_IDENT || nextToken == TOK_OPENPAREN || 
            nextToken == TOK_NOT || nextToken == TOK_MINUS);
}

/********
 * TERM *
 ********/

TermNode* term() {
	if (!first_of_term()) {
        throw "902: illegal type of term";
    } else {
		if(printParse) output("TERM");
	}
	
	if(printParse)
		cout << psp() << "enter <term>" << endl;
    TermNode* newTermNode = new TermNode(level);
	++level;
	
	// Parse factor
	newTermNode->_firstFactor = factor();
	
    // Optional operators
	while (nextToken == TOK_MULTIPLY || nextToken == TOK_DIVIDE || nextToken == TOK_AND) {
        if(printParse) {
			if (nextToken == TOK_MULTIPLY) {
				output("MULTIPLY");
				cout << psp() << yytext << "\n";
			} else if (nextToken == TOK_DIVIDE) {
				output("DIVIDE");
				cout << psp() << yytext << "\n";
			} else {
				output("AND");
				cout << psp() << yytext << "\n";
			}
		}
		newTermNode->_factorOps.push_back(nextToken);
		lex();
		newTermNode->_restFactors.push_back(factor());
    }
	
    --level;
	if(printParse)
		cout << psp() << "exit <term>" << endl;
	return newTermNode;
}

bool first_of_term(void) {
	return (nextToken == TOK_INTLIT || nextToken == TOK_FLOATLIT || 
            nextToken == TOK_IDENT || nextToken == TOK_OPENPAREN || 
            nextToken == TOK_NOT || nextToken == TOK_MINUS);
}

/**********
 * FACTOR *
 **********/

FactorNode* factor() {
	if (!first_of_factor()) {
        throw "903: illegal type of factor";
    } else {
		if(printParse) output("FACTOR");
	}
	
	if(printParse)
		cout << psp() << "enter <factor>" << endl;
    FactorNode* newFactorNode = nullptr;
	++level;
	
	if (nextToken == TOK_INTLIT) {
		if(printParse) {
			output("INTLIT");
			cout << psp() << yytext << "\n";
		}
		newFactorNode = new IntLitNode(--level, atoi(yytext));
		++level;
		lex();
    }
	
	else if (nextToken == TOK_FLOATLIT) {
        if(printParse) {
			output("FLOATLIT");
			cout << psp() << yytext << "\n";
		}
		newFactorNode = new FloatLitNode(--level, stof(yytext));
		++level;
		lex();
    }
	
	else if (nextToken == TOK_IDENT) {
		if (symbolTable.count(yytext) == 0) {
			if(printParse) {
				output("IDENTIFIER");
				cout << psp() << yytext << "\n";
			}
			throw "104: identifier not declared";;
		} else {
			if(printParse) {
				output("IDENTIFIER");
				cout << psp() << yytext << "\n";
			}
			newFactorNode = new IdNode(--level, string(yytext));
			++level;
			lex();
		}
	}
	
	else if (nextToken == TOK_OPENPAREN) {
		if(printParse) {
			output("OPENPAREN");
			cout << psp() << yytext << "\n";
		}
		lex();
		newFactorNode = new NestedExprNode(level, expression());
		if (nextToken == TOK_CLOSEPAREN) {
			if(printParse) output("CLOSEPAREN");
			lex();
		} else {
			throw "4: ')' expected";
		}
	}
	
	else if (nextToken == TOK_NOT) {
		if(printParse) {
			output("NOT");
			cout << psp() << yytext << "\n";
		}
		lex();
		newFactorNode = new NotNode(level, factor());
	}
	
	else if (nextToken == TOK_MINUS) {
		if(printParse) {
			output("MINUS");
			cout << psp() << yytext << "\n";
		}
		lex();
		newFactorNode = new MinusNode(level, factor());
	}
	
    --level;
	if(printParse)
		cout << psp() << "exit <factor>" << endl;
	return newFactorNode;
}

bool first_of_factor(void) {
	return (nextToken == TOK_INTLIT || nextToken == TOK_FLOATLIT || 
            nextToken == TOK_IDENT || nextToken == TOK_OPENPAREN || 
            nextToken == TOK_NOT || nextToken == TOK_MINUS);
}
